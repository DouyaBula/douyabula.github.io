{"pages":[{"title":"about","text":"Welcome.","link":"/about/index.html"}],"posts":[{"title":"Digital Design and Computer Architecture 第三章归纳","text":"0 前言这一章学习Sequential Logic。首先学习几个基本元件，接着学习有限状态机，最后学习Timing分析。其中穿插了设计电路的原则和提高电路效率的方法。 从这篇笔记开始简化内容，一些直觉上认为不重要的内容就略过了。我是懒狗。 1 时序逻辑模块Bistable ElementThe fundamental building block of memory is a bistable element, an element with two stable states. SR Latch D LatchThe data input, D, controls what the next state should be. The clock input, CLK, controls when the state should change. D Flip-FlopA D flip-flop copies D to Q on the rising edge of the clock, and remembers its state at all other times. The term flip-flop or latch by itself usually refers to a D flip-flop or D latch, respectively, because these are the types most commonly used in practice. RegisterAn N-bit register is a bank of N flip-flops that share a common CLK input, so that all bits of the register are updated at the same time. Enabled Flip-FlopAn enabled flip-flop adds another input called EN or ENABLE to determine whether data is loaded on the clock edge. Resettable Flip-FlopA resettable flip-flop adds another input called RESET. When RESET is FALSE, the resettable flip-flop behaves like an ordinary D flip-flop. When RESET is TRUE, the resettable flip-flop ignores D and resets the output to 0. Such flip-flops may be synchronously or asynchronously resettable. Transistors-Level Designs 2 设计原则Definition of a Synchronous Sequential CircuitA circuit is a synchronous sequential circuit if it consists of interconnected circuit elements such that Every circuit element is either a register or a combinational circuit At least one circuit element is a register All registers receive the same clock signal Every cyclic path contains at least one register. Sequential circuits that are not synchronous are called asynchronous. Asynchronous design in theory is more general than synchronous design, because the timing of the system is not limited by clocked registers. However, synchronous circuits have proved to be easier to design and use than asynchronous circuits 3 有限状态机DefinitionSynchronous sequential circuits can be drawn in the forms shown in Figure 3.22. These forms are called finite state machines (FSMs). They get their name because a circuit with k registers can be in one of a finite number ($2^k$) of unique states. In Moore machines, the outputs depend only on the current state of the machine. In Mealy machines, the outputs depend on both the current state and the current inputs. ExamplesA controller for a traffic light （Moore Machine） State transition diagram State transition table Encodings Boolean Equations$$S’_1=\\bar{S_1}S_0+S_1\\bar{S_0}\\bar{T_B}+S_1\\bar{S_0}T_B\\S’_0=\\bar{S_1}\\bar{S_2}\\bar{T_A}+S_1\\bar{S_0}\\bar{T_B}$$ Simplify it. $$S’_1=S_1\\oplus S_0\\S’_0=\\bar{S_1}\\bar{S_2}\\bar{T_A}+S_1\\bar{S_0}\\bar{T_B}$$ Similarly, get the output equations. $$L_{A1}=S_1\\L_{A0}=\\bar{S_1}S_0\\L_{B1}=\\bar{S_1}\\L_{B0}=S_1S_0$$ Draw the diagram Mealy MachineThe snail crawls from left to right along a paper tape containing a sequence of 1’s and 0’s. On each clock cycle, the snail crawls to the next bit. The snail smiles when the last two bits that it has crawled over are, from left to right, 01. Design the FSM to compute when the snail should smile. Factoring State Machines Encoding patterns With binary encoding, as was used in the traffic light controller example, each state is represented as a binary number. In one-hot encoding, a separate bit of state is used for each state. A different choice would have resulted in a different circuit. Deriving an FSM from a SchematicDeriving the state transition diagram from a schematic follows nearly the reverse process of FSM design. Examine circuit, stating inputs, outputs, and state bits. Write next state and output equations. Create next state and output tables. Reduce the next state table to eliminate unreachable states. Assign each valid state bit combination a name. Rewrite next state and output tables with state names. Draw state transition diagram. State in words what the FSM does. 4 TimingThe Dynamic DisciplineThe sum of the setup and hold times is called the aperture time of the circuit, because it is the total time for which the input must remain stable. 拓展阅读： 为什么会有建立时间(setup time)和保持时间(hold time)要求? https://zhuanlan.zhihu.com/p/269274800 网页备份： https://pan.baidu.com/s/1Rv0rat9MAu3v6H48-Mrc7A?pwd=fbbg Setup Time Constraint$$t_{pd}\\leq T_C-(t_{pcq}+t_{setup})$$ This equation is called the setup time constraint or max-delay constraint. Hold Time Constraint$$t_{cd}\\geq t_{hold}-t_{cq}$$ This is also called the hold time constraint or min-delay constraint. Clock SkewIn the previous analysis, we assumed that the clock reaches all registers at exactly the same time. In reality, there is some variation in this time. This variation in clock edges is called clock skew. MetastabilityWhen a flip-flop samples an input that is changing during its aperture, the output Q may momentarily take on a voltage between 0 and $V_{DD}$ that is in the forbidden zone. This is called a metastable state.$$P(t_{res}&gt;t)=\\frac{T_0}{T_c}e^{-\\frac{t}{\\tau}}$$公式推导略。 $T_c$ is the clock period, and $T_0$ and $\\tau$ are characteristic of the flip-flop. The equation is valid only for t substantially longer than $t_{pcq}$. SynchronizersTo guarantee good logic levels, all asynchronous inputs should be passed through synchronizers. $$P(failure)=\\frac{T_0}{T_c}e^{-\\frac{T_c-t_{setup}}{\\tau}}$$If D changes N times per second:$$P(failure)/sec=N\\frac{T_0}{T_c}e^{-\\frac{T_c-t_{setup}}{\\tau}}$$System reliability is usually measured in mean time between failures (MTBF):$$MTBF=\\frac{1}{P(failure)/sec}=\\frac{T_ce^{-\\frac{T_c-t_{setup}}{\\tau}}}{NT_0}$$ 5 Parallelism We define a token to be a group of inputs that are processed to produce a group of outputs. The latency of a system is the time required for one token to pass through the system from start to end. The throughput is the number of tokens that can be produced per unit time. With spatial parallelism, multiple copies of the hardware are provided so that multiple tasks can be done at the same time. With temporal parallelism, a task is broken into stages, like an assembly line. Multiple tasks can be spread across the stages. Temporal parallelism is commonly called pipelining.","link":"/2022/08/03/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%BD%92%E7%BA%B3/"},{"title":"Digital Design and Computer Architecture 第一章归纳","text":"0 前言笔记主要是对教材的关键部分进行摘录并归类，方便以后查阅。 1 研究方法 Abstraction（抽象） The critical technique for managing complexity is abstraction: hiding details when they are not important. A system can be viewed from many different levels of abstraction. Discipline（标准） Discipline is the act of intentionally restricting your design choices so that you can work more productively at a higher level of abstraction. The Three-Y’s（三原则） Designers use the three “-y’s” to manage complexity: hierarchy, modularity, and regularity. Hierarchy involves dividing a system into modules, then further sub-dividing each of these modules until the pieces are easy to understand. Modularity states that the modules have well-defined functions and interfaces, so that they connect together easily without unanticipated side effects. Regularity seeks uniformity among the modules. Common modules are reused many times, reducing the number of distinct modules that must be designed. 2 数制Bits, Bytes, Nibbles The amount of information D in a discrete valued variable with N distinct states is measured in units of bits as: $$D=log_2N\\space\\space\\space bits$$ A group of eight bits is called a byte. A group of four bits, or half a byte, is called a nibble. Microprocessors handle data in chunks called words. The size of a word depends on the architecture of the microprocessor. Within a group of bits, the bit in the 1’s column is called the least significant bit (lsb), and the bit at the other end is called the most significant bit (msb). Similarly, within a word, the bytes are identified as least significant byte (LSB) through most significant byte (MSB). Some Number Systems Decimal Numbers Base: 10. Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Binary Numbers Base:2. Digits:0, 1. Hexadecimal Numbers Base: 16. Digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Signed Binary Numbers SignMagnitude Numbers An N-bit signmagnitude number uses the most significant bit as the sign and the remaining N−1 bits as the magnitude (absolute value). A sign bit of 0 indicates positive and a sign bit of 1 indicates negative. Two’s Complement Numbers Two’s complement numbers are identical to unsigned binary numbers except that the most significant bit position has a weight of $-2^{N-1}$ instead of $2^{N-1}$. Taking the two’s complement: The sign of a two’s complement number is reversed in a process called taking the two’s complement. The process consists of inverting all of the bits in the number, then adding 1 to the least significant bit position. This is useful to find the representation of a negative number or to determine the magnitude of a negative number. 3 逻辑门Some Logic Gates AND Buffer NOT OR NAND NOR XOR 4 数字抽象之下Basic Concepts Suppose the lowest voltage in the system is 0 V, also called ground or GND. The highest voltage in the system comes from the power supply and is usually called $\\bf{V_{DD}}$. The mapping of a continuous variable onto a discrete binary variable is done by defining logic levels. The noise margin is the amount of noise that could be added to a worst-case output such that the signal can still be interpreted as a valid input. DC Transfer CharacteristicsThe DC transfer characteristics of a gate describe the output voltage as a function of the input voltage when the input is changed slowly enough that the output can keep up. A reasonable place to choose the logic levels is where the slope of the transfer characteristic $\\frac{dY}{dA}$ is −1. These two points are called the unity gain points. Choosing logic levels at the unity gain points usually maximizes the noise margins. 5 CMOS晶体管Basic Gadgets Semiconductors The electron carries a negative charge, so we call arsenic an n-type dopant. The hole is a lack of negative charge, so it acts like a positively charged particle. Hence, we call boron a p-type dopant. Diodes The junction between p-type and n-type silicon is called a diode. The p-type region is called the anode and the n-type region is called the cathode. When the voltage on the anode rises above the voltage on the cathode, the diode is forward biased. When the anode voltage is lower than the voltage on the cathode, the diode is reverse biased. Capacitors A capacitor consists of two conductors separated by an insulator. nMOS and pMOS TransistorsThere are two flavors of MOSFETs: nMOS and pMOS. CMOS GatesThese processes that provide both flavors of transistors are called Complementary MOS or CMOS. Some CMOS Gates NOT NAND Transmission Gate The general form used to construct any inverting logic gate: In a properly functioning logic gate, one of the networks should be ON and the other OFF at any given time, so that the output is pulled HIGH or LOW but not shorted or floating. We can guarantee this by using the rule of conduction complements. When nMOS transistors are in series, the pMOS transistors must be in parallel. When nMOS transistors are in parallel, the pMOS transistors must be in series. Pseudo-nMOS LogicPseudo-nMOS logic replaces the slow stack of pMOS transistors with a single weak pMOS transistor that is always ON. Power Consumption$$P_{dynamic}=\\frac{1}{2}CV_{DD}^2f$$ $$P_{static}=I_{DD}V_{DD}$$","link":"/2022/07/18/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%BD%92%E7%BA%B3/"},{"title":"Digital Design and Computer Architecture 第二章归纳","text":"0 前言这一章的布尔方程和布尔代数部分在离散里已经学过了，但是讲的比离散课本好十万甚至九万倍。 Timing部分在数据结构的图里学过。 1 基本概念CircuitIn digital electronics, a circuit is a network that processes discrete-valued variables. A circuit can be viewed as a black box, shown in Figure 2.1, with one or more discrete-valued input terminals one or more discrete-valued output terminals a functional specification describing the relationship between inputs and outputs a timing specification describing the delay between inputs changing and outputs responding. Circuits are composed of nodes and elements. An element is itself a circuit with inputs, outputs, and a specification. A node is a wire, whose voltage conveys a discrete-valued variable. Nodes are classified as input, output, or internal. Inputs receive values from the external world. Outputs deliver values to the external world. Wires that are not inputs or outputs are called internal nodes. Nodes A, B, and C are inputs. Y and Z are outputs. n1 is an internal node between E1 and E3. Combinational and Sequential Circuits A combinational circuit’s outputs depend only on the current values of the inputs. A sequential circuit’s outputs depend on both current and previous values of the inputs. To simplify drawings, we often use a single line with a slash through it and a number next to it to indicate a bus, a bundle of multiple signals. If the number of bits is unimportant or obvious from the context, the slash may be shown without a number. The symbol $C\\L$ inside the box indicates that it is implemented using only combinational logic. The rules of combinational compositionA circuit is combinational if it consists of interconnected circuit elements such that Every circuit element is itself combinational. Every node of the circuit is either designated as an input to the circuit or connects to exactly one output terminal of a circuit element. The circuit contains no cyclic paths: every path through the circuit visits each circuit node at most once. 2 布尔方程与布尔代数Terminology The complement of a variable $A$ is its inverse $\\overline{A}$. We call A the true form of the variable and A the complementary form. The variable or its complement is called a literal. The AND of one or more literals is called a product or an implicant. An implicant is called a prime implicant if it cannot be combined with any other implicants in the equation to form a new implicant with fewer literals. A minterm is a product involving all of the inputs to the function. The OR of one or more literals is called a sum. A maxterm is a sum involving all of the inputs to the function. Order of operations: NOT &gt; AND &gt; OR. Sum-of-products FormSum-of-products canonical form is a Boolean equation for any truth table by summing each of the minterms for which the output is TRUE. Product-of-Sums FormProduct-of-sums canonical form is a Boolean equation for any truth table by multiplying each of the maxterms for which the output is FALSE. Attention: Sum-of-products and product-of-sums form do not necessarily generate the simplest equation. Axioms Theorems 3 构建组合逻辑电路Rules for bubble pushingAccording to the theorems, the underlying rules for bubble pushing are Pushing bubbles backward (from the output) or forward (from the inputs) changes the body of the gate from AND to OR or vice versa. Pushing a bubble from the output back to the inputs puts bubbles on all gate inputs. Pushing bubbles on all gate inputs forward toward the output puts a bubble on the output. Drawing SchematicsA schematic is a diagram of a digital circuit showing the elements and the wires that connect them together. By drawing schematics in a consistent fashion, we make them easier to read and debug. We will generally obey the following guidelines: Inputs are on the left (or top) side of a schematic. Outputs are on the right (or bottom) side of a schematic. Whenever possible, gates should flow from left to right. Straight wires are better to use than wires with multiple corners (jagged wires waste mental effort following the wire rather than thinking of what the circuit does). Wires always connect at a T junction. A dot where wires cross indicates a connection between the wires. Wires crossing without a dot make no connection. Priority Circuit We use the symbol X to describe inputs that the output doesn’t care about. Bubble Pushing The guidelines for bubble pushing are as follows: Begin at the output of the circuit and work toward the inputs. Push any bubbles on the final output back toward the inputs so that you can read an equation in terms of the output (for example, $Y$) instead of the complement of the output $\\overline Y$. Working backward, draw each gate in a form so that bubbles cancel. If the current gate has an input bubble, draw the preceding gate with an output bubble. If the current gate does not have an input bubble, draw the preceding gate without an output bubble. Illegal Value and Floating ValueThe symbol X indicates that the circuit node has an unknown or illegal value. This commonly happens if it is being driven to both 0 and 1 at the same time. The symbol Z indicates that a node is being driven neither HIGH nor LOW. The node is said to be floating, high impedance, or high Z. A floating node might be 0, might be 1, or might be at some voltage in between, depending on the history of the system. The tristate buffer, shown in Figure 2.40, has three possible output states: HIGH (1), LOW (0), and floating (Z). 4 卡诺图Karnaugh maps (K-maps) are a graphical method for simplifying Boolean equations. Adjacent squares share all the same literals except one, which appears in true form in one square and in complementary form in the other. You may have noticed that the A and B combinations in the top row are in a peculiar order: 00, 01, 11, 10. This order is called a Gray code. The K-map also “wraps around.” Logic Minimization with K-MapsK-maps provide an easy visual way to minimize logic. Rules for finding a minimized equation from a K-map are as follows: Use the fewest circles necessary to cover all the 1’s. All the squares in each circle must contain 1’s. Each circle must span a rectangular block that is a power of 2 (i.e., 1, 2, or 4) squares in each direction. Each circle should be as large as possible. A circle may wrap around the edges of the K-map. A 1 in a K-map may be circled multiple times if doing so allows fewer circles to be used. Seven-segment Display Decoder Don‘t CaresDon’t cares also appear in truth table outputs where the output value is unimportant or the corresponding input combination can never happen. Such outputs can be treated as either 0’s or 1’s at the designer’s discretion. 5 组合逻辑模块Multiplexers Multiplexer LogicMultiplexers can be used as lookup tables to perform logic functions. In general, a $2^N$-input multiplexer can be programmed to perform any N-input logic function by applying 0’s and 1’s to the appropriate data inputs. With a little cleverness, we can cut the multiplexer size in half, using only a $2^{N-1}$-input multiplexer to perform any N-input logic function. Decoder Decoder LogicWhen using decoders to build logic, it is easiest to express functions as a truth table or in canonical sum-of-products form. An N-input function with M 1’s in the truth table can be built with an N:2N decoder and an M-input OR gate attached to all of the minterms containing 1’s in the truth table. 5 TimingPropagation and Contamination DelayThe propagation delay $t_{pd}$ is the maximum time from when an input changes until the output or outputs reach their final value. The contamination delay $t_{cd}$ is the minimum time from when an input changes until any output starts to change its value. Critical Path and Short PathThe critical path limits the speed at which the circuit operates. The short path is the fastest path through the circuit. The propagation delay of a combinational circuit is the sum of the propagation delays through each element on the critical path. The contamination delay is the sum of the contamination delays through each element on the short path. GlitchesIt is possible that a single input transition can cause multiple output transitions. These are called glitches or hazards. In general, a glitch can occur when a change in a single variable crosses the boundary between two prime implicants in a K-map. We can eliminate the glitch by adding redundant implicants to the K-map to cover these boundaries. This of course comes at the cost of extra hardware. However, simultaneous transitions on multiple inputs can also cause glitches. These glitches cannot be fixed by adding hardware.","link":"/2022/07/22/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BD%92%E7%BA%B3/"},{"title":"Digital-Design-and-Computer-Architecture-第六章归纳","text":"0 前言这一章主要学习MIPS架构，黑书的结构感觉有点混乱，所以按一定的逻辑重新组织了一下各个部分的内容。这一篇笔记类似于“字典”的形式，方便复习或查阅。 1 Four Principles in MIPS Design Simplicity favors regularity. Make the common case fast. Smaller is faster. Good design demands good compromises. 2 Three OperandsRegister Set/Register File Name Number(5 bits) Use ＄0 0 the constant value 0 ＄at 1 assembler temporary ＄v0-＄v1 2-3 function return value ＄a0-＄a3 4-7 function arguments ＄t0-＄t7 8-15 temporary variables ＄s0-＄s7 16-23 saved variables ＄t8-＄t9 24-25 temporary variables ＄k0-＄k1 26-27 operating system (OS) temporaries ＄gp 28 global pointer ＄sp 29 stack pointer ＄fp 30 frame pointer ＄ra 31 function return address MemoryOrganization Pattern MIPS uses a byte-addressable memory. Big-Endian and Little-Endian: Memory Map Constants/ImmediatesThe immediate specified in an instruction is a 16-bit two’s complement number in the range [–32,768, 32,767]. 3 Instructions SetR-TypeInstruction Format I-TypeInstruction Format J-TypeInstruction Format F-TypeInstruction Format Addressing Modes Register-Only Addressing Register-only addressing uses registers for all source and destination operands. All R-type instructions use register-only addressing. Immediate Addressing Immediate addressing uses the 16-bit immediate along with registers as operands. Some I-type instructions, such as add immediate (addi) and load upper immediate (lui), use immediate addressing. Base Addressing Memory access instructions, such as load word (lw) and store word (sw), use base addressing. The effective address of the memory operand is found by adding the base address in register rs to the sign-extended 16-bit offset found in the immediate field. PC-Relative Addressing Conditional branch instructions use PC-relative addressing to specify the new value of the PC if the branch is taken. The 16-bit immediate field gives the number of instructions between the BTA and the instruction after the branch instruction. Pseudo-Direct Addressing The J-type instruction encoding does not have enough bits to specify a full 32-bit JTA. Fortunately, the two least significant bits, $JTA_{1:0}$, should always be 0, because instructions are word aligned. The next 26 bits, $JTA_{27:2}$, are taken from the addr field of the instruction. The four most significant bits, $JTA_{31:28}$, are obtained from the four most significant bits of PC + 4. This addressing mode is called pseudo-direct. Because the four most significant bits of the JTA are taken from PC + 4,the jump range is limited. MIPS Instructions Tables 4 Programming32-Bit Constant The and instruction is useful for masking bits. The or instruction is useful for combining bits from two registers. A NOR ＄0 = NOT A. 123456789# 32-BIT CONSTANT# High-Level Codeint a = 0x6d5e4f3c;#MIPS Assembly Code# $s0=a lui $s0, 0x6d5e ori $s0, $s0, 0x4f3c Conditional Statementsif Statement12345678910# High-Level Languageif (i==j) f=g+h;f=f-i;#MIPS Assemble Language# $s0=f, $s1=g, $s2=h, $s3=i, s4=j bne $s3, $s4, target # if $s3 != $s4 then target add $s1, $s2, $s3 # $s1 = $s2 + $s3target: sub $s1, $s1, $s3 # $s1 = $s1 - $s3 if/else Statement12345678910111213# High-Level Languageif (i==j) f=g+h;else f=f-i;#MIPS Assemble Language# $s0=f, $s1=g, $s2=h, $s3=i, s4=j bne $s3, $s4, else # if $s3 != $s4 then else add $s1, $s2, $s3 # $s1 = $s2 + $s3 j target # jump to targetelse: sub $s1, $s1, $s3 # $s1 = $s1 - $s3target: switch/case Statement123456789101112131415161718192021222324252627# Hight-Level Languageswtich (amount){ case 20: fee=2; break; case 50: fee=3; break; case 100: fee=5; break; default: fee=0;}#MIPS Assemble Language# $s0=fee, $s1=amountcase20: add $t0, $0, 20 # $t0 = $0 + 20 bne $t0, $s1, case50 # if $t0 != $s1 then case50 addi $s0, $0, 2 # $s0 = $0 + 2 j done # jump to donecase50: add $t0, $0, 50 bne $t0, $s1, case100 addi $s0, $0, 3 j done case100: add $t0, $0, 100 bne $t0, $s1, default addi $s0, $0, 5 j done default: addi $s0, $0, 0 done: Loop Statementwhile Loop12345678910111213141516171819# High-Level Languageint pow=1;int x=0;while(pow!=128){ pow=pow*2; x=x+1;}# MIPS Assemble Language# $s0=pow, $s1=x addi $s0, $0, 1 # $s0 = $0 + 1 addi $s1, $0, 0 # $s1 = $0 + 0 addi $t0, $0, 128 # $t0 = $0 + 128while: beq $s0, $t0, target # if $s0 == $t0 then target sll $s0, $s0, 1 # $s0 = $s0 &lt;&lt; 1 addi $s1, $0, 1 # $s1 = $0 + 1 j while # jump to whiletarget: for Loop123456789101112131415161718192021222324252627282930# for Loop# High-Level Languageint sum=0;for (i=0:i!=10:i=i+1){ sum=sum+i;}# MIPS Assemble Language# $s0=sum, $s1=i addi $s0, $0, 0 # $s0 = $0 + 0 addi $s1, $0, 0 # $s1 = $0 + 0 addi $t0, $0, 10 # $t0 = $0 + 10for: beq $s1, $t0, target # if $s1 == $t0 then target add $s0, $s0, $s1 # $s0 = $s0 + $t0 addi $s1, $s1, 1 # $s1 = $s1 + 1 j for # jump to fortarget:# Using slt Ver. addi $s0, $0, 0 # $s0 = $0 + 0 addi $s1, $0, 0 # $s1 = $0 + 0 addi $t0, $0, 11 # $t0 = $0 + 10for: slt $t1, $s1, $t0 # $t1 = ($s1 &lt; $t0) ? 1 : 0 beq $t1, $0, target # if $t1 == $0 then target add $s0, $s0, $s1 # $s0 = $s0 + $s1 addi $s1, $s1, 1 # $s1 = $s1 + 1 j for # jump to fortarget: FunctionExample 112345678910111213141516171819202122232425262728293031# High-Level Languageint main(){ int y; y=diffofsums(2,3,4,5);}int diffofsums(int f,int g,int h,int i){ int result; result=(f+g)-(h+i); return result;}# MIPS Assemble Language# $s0=ymain: addi $a0, $0, 2 # $a0 = $0 + 2 addi $a1, $0, 3 # $a1 = $0 + 3 addi $a2, $0, 4 # $a2 = $0 + 4 addi $a3, $0, 5 # $a3 = $0 + 5 jal diffofsums # jump to diffofsums and save position to $ra add $s0, $v0, $0 # $s0 = $v0 + $0 ...# $s0=resultdiffofsums: addi $sp, $sp, -4 # $sp = $sp + -4 sw $s0, 0($sp) add $t0, $a0, $a1 # $t0 = $t0 + $t1 add $t1, $a2, $a3 # $t1 = $a2 + $a3 sub $s0, $t0, $t1 # $s0 = $t0 - $t1 add $v0, $0, $s0 # $v0 = $0 + $s0 lw $s0, 0($sp) addi $sp, $sp, 4 # $sp = $sp + 4 jr $ra # jump to $ra Example 2 (Recursive Function)1234567891011121314151617181920212223242526# High-Level Languageint factorial(int n){ if(n&lt;=1) return 1; else return (n*factorial(n-1));}# MIPS Assemble Languagefactorial: addi $sp, $sp, -8 # $sp = $sp + -8 sw $a0, 4($sp) sw $ra, 0($sp) addi $t0, $0, 2 # $t0 = $0 + 2 slt $t0, $a0, $t0 # $t0 = ($a0 &lt; $t0) ? 1 : 0 beq $t0, $0, else # if $t0 == $0 then else addi $v0, $0, 1 # $v0 = $0 + 1 addi $sp, $sp, 8 # $sp = $sp + 8 jr $ra # jump to $raelse: addi $a0, $0, -1 # $a0 = $0 + -1 jal factorial # jump to factorial and save position to $ra lw $ra, 0($sp) lw $a0, 4($sp) addi $sp, $sp, 8 # $sp = $sp + 8 mul $v0, $v0, $a0 jr $ra # jump to $ra 5 Compiling, Assembling, and Loading Compilation: A compiler translates high-level code into assembly language. Assembling: The assembler turns the assembly language code into an object file containing machine language code. On the first pass, the assembler assigns instruction addresses and finds all the symbols, such as labels and global variable names. The names and addresses of the symbols are kept in a symbol table. On the second pass through the code, the assembler produces the machine language code. Addresses for the global variables and labels are taken from the symbol table. The machine language code and symbol table are stored in the object file. Linking: The job of the linker is to combine all of the object files into one machine language file called the executable. Loading: The operating system loads a program by reading the text segment of the executable file from a storage device (usually the hard disk) into the text segment of memory. The operating system sets ＄gp to 0x10008000 (the middle of the global data segment) and ＄sp to 0x7FFFFFFC (the top of the dynamic data segment), then performs a jal 0x00400000 to jump to the beginning of the program.","link":"/2022/09/05/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%BD%92%E7%BA%B3/"},{"title":"Digital-Design-and-Computer-Architecture-第五章归纳","text":"0 前言这一章学习了小数的二进制表示，一些更复杂的blocks，对之前的很多内容做了拓展和补充。 1 Number SystemsFixed-Point NumberFixed-point notation has an implied binary point between the integer and fraction bits, analogous to the decimal point between the integer and fraction digits of an ordinary decimal number. There is no way of knowing the existence of the binary point except through agreement of those people interpreting the number. Floating-Point Number SystemsSign: 0+, 1-. Biased Exponent: Original exponent +127. (32bit) Fraction: The first bit of mantissa is erased. Special Cases Formats Rounding The rounding modes are: round down, round up, round toward zero, and round to nearest. The default rounding mode is round to nearest. A number overflows to $\\pm \\infty$ when its magnitude is too large to be represented. Likewise, a number underflows to $0$ when it is too tiny to be represented. Floating-Point Addition Extract exponent and fraction bits. Prepend leading 1 to form the mantissa. Compare exponents. Shift smaller mantissa if necessary. Add mantissas. Normalize mantissa and adjust exponent if necessary. Round result. Assemble exponent and fraction back into floating-point number. 2 Arithmetic CircuitsAdditionHalf Adder Full Adder Ripple Carry Adder Carry Lookahead Adder (CLA)$$G_i=A_iB_i\\P_i=A_i+B_i\\C_i=G_i+P_iC_{i-1}$$ As for multiple-bit occasions,$$G_{i:j}=C_i\\P_{i:j}=\\prod_{k=i}^jP_k\\C_{i:j}=G_{i:j}+P_{i:j}C_{in}$$ Prefix AdderThey first compute G and P for pairs of columns, then for blocks of 4, then for blocks of 8, then 16, and so forth until the generate signal for every column is known. The sums are computed from these generate signals. SubtractionSubtraction is almost as easy: flip the sign of the second number, then add. ComparatorsEquality ComparatorMagnitude ComparatorMagnitude comparison is usually done by computing A − B and looking at the sign (most significant bit) of the result as shown in Figure 5.12. Arithmetic/Logical Unit (ALU) Shifters Multiplication Division略 3 Sequential Building BlocksCounter 12345678module counter #(parameter N=8) (input clk, rst output [N-1:0] q); always@(posedge clk,posedge rst) begin if (rst) q&lt;=4'b0000; else q&lt;=q+1; endendmodule Shift Register 123456789101112module shiftReg #(parameter N=8) (input [N-1:0]d, input clk,load,rst,sin, output [N-1:0] q, output sout) always@(posedge clk,posedge rst) begin if(rst) q&lt;=0; else if(load) q&lt;=d; else q&lt;={q[N-2:0],sin}; end assign sout=q[N-1];endmodule Scan Chains 4 Memory Arrays Memories are classified based on how they store bits in the bit cell. The broadest classification is random access memory (RAM) versus read only memory (ROM). RAM is volatile, meaning that it loses its data when the power is turned off. ROM is nonvolatile, meaning that it retains its data indefinitely, even without a power source. RAM and ROM received their names for historical reasons that are no longer very meaningful. DRAM SRAM ROM 12345678910module RAM #(parameter N=6, M=32) (input clk, we, input [M-1:0] adr,din, output [M-1:0] dout) reg [M-1:0] mem [2**N-1:0]; always@(posedge clk) begin if(we) mem[adr]&lt;=din; end assign dout=mem[adr];endmodule PROMFuse-programmable ROM Memory arrays used to perform logic are called lookup tables (LUTs). 5 Logic ArraysPLA FPGAFPGAs are built as an array of configurable logic elements (LEs), also referred to as configurable logic blocks (CLBs). Each LE can be configured to perform combinational or sequential functions. The LEs are surrounded by input/output elements (IOEs) for interfacing with the outside world. 6 Array ImplementationsRefer to Chapter 1.","link":"/2022/09/03/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%BD%92%E7%BA%B3/"},{"title":"Hello World","text":"TestTest 公式 $$\\sum_{n=1}^{114514}1919.810$$ 图片","link":"/2022/07/13/world/"},{"title":"Digital Design and Computer Architecture 第四章归纳","text":"0 前言123补充：做完了教程平台里前三章的题，发现logisim里的多输入异或门和教材里描述的行为有差异。教材里的多输入异或门起到奇偶校验的作用，而logisim里有单独的odd/even gates。 这章学习硬件描述语言，因为课程要求就只看Verilog的部分了。 突如其来的脑洞： 1 概念ModuleA block of hardware with inputs and outputs is called a module. Simulation and SynthesisDuring simulation, inputs are applied to a module, and the outputs are checked to verify that the module operates correctly. During synthesis, the textual description of a module is transformed into logic gates. 2 Examples &amp; IdiomsIn our experience, the best way to learn an HDL is by example. HDLs have specific ways of describing various classes of logic; these ways are called idioms. Combinational Logicsillyfunction123456module sillyfunction(input logic a,b,c output logic y); assign y=~a&amp;~b&amp;~c| a&amp;~b&amp;~c| a&amp;~b&amp; c;endmodule Bitwise OperatorsInverters1234module inv(input logic [3:0] a, output logic [3:0] y); assign y=~a;endmodule Logic Gates12345678module gates(input logic [3:0] a, b, output logic [3:0] y1, y2, y3, y4, y5); assign y1=a&amp;b;//AND assign y2=a|b;//OR assign y3=a^b;//XOR assign y4=~(a&amp;b);//NAND assign y5=~(a|b);//NORendmodule Reduction OperatorsEight-Input AND1234module and8(input logic [7:0] a, output logic y); assign y=&amp;a;endmodule Conditional Assignment2:1 Multiplexer12345module mux2(input logic [3:0] d0, d1, input logic s, output logic [3:0] y); assign y= s?d1:d0;endmodule 4:1 Multiplexer12345module mux4(input logic [3:0] d0,d1,d2,d3, input logic [1:0] s, output logic [3:0] y); assign y=s[1]?(s[0]?d3:d2):(s[0]?d1:d0);endmodule Internal VariablesFull Adder12345678module fulladder(input logic a, b, cin, output logic s, cout); logic p, g; assign p=a^b; assign g=a&amp;b; assign s=p^cin; assign cout=g|(p&amp;cin);endmodule Z’s and X’sTristate BuffersTristate busses can have multiple drivers, so they should be declared as a net. Two types of nets in SystemVerilog are called tri and trireg. 12345module tristate(input logic [3:0] a. input logic en, output tri [3:0] y); assign y=en?a:4'bz;endmodule Bit Swizzling1assign y={c[2:1],{3{d[0]}},c[0],3'b101} DelaysLogic Gates with Delays12345678910'timescale 1ns/1psmodule example(input logic a,b,c, output logic y); logic ab,bb,cb,n1,n2,n3; assign #1 {ab,bb,cb}=~{a,b,c}; assign #2 n1=ab&amp;bb&amp;cb; assign #2 n2=a&amp;bb&amp;cb; assign #2 n3=a&amp;bb&amp;c; assign #4 y=n1|n2|n3;endmodule Structural ModelingStructural Model of 4:1 Multiplexers12345678module mux4(input logic [3:0] d0, d1, d2, d3, input logic [1:0] s, output logic [3:0] y) logic [3:0] low, high; mux2 lowmux(d0, d1, s[0], low); mux2 highmux(d2, d3, s[0], high); mux2 finalmux(low, high, s[1], y);endmodule Accessing Parts of Busses123456module mux2_8(input logic [7:0] d0, d1. input logic s, output logic [7:0] y); mux2 lsbmux(d0[3:0], d1[3:0], s, y[3:0]); mux2 msbmux(d0[7:4], d1[7:4], s, y[7:4]);endmodule Sequential LogicRegister123456module flop(input logic clk, input logic [3:0] d, output logic [3:0] q); always_ff @(posedge clk) q&lt;=d;endmodule Resettable Register1. Asynchronous 12345678module flopr(input logic clk, input logic reset, input logic [3:0] d, output logic [3:0] q); always_ff @(posedge clk, posedge reset) if(reset) q&lt;=4'b0; else q&lt;=d;endmodule 2. Synchronous 12345678module flopr(input logic clk, input logic reset, input logic [3:0] d, output logic [3:0] q); always_ff @(posedge clk) if(reset) q&lt;=4'b0; else q&lt;=d;endmodule Enabled Register123456789module flopr(input logic clk, input logic reset, input logic en, input logic [3:0] d, output logic [3:0] q); always_ff @(posedge clk, posedge reset) if(reset) q&lt;=4'b0; else if(en) q&lt;=d;endmodule Synchronizer12345678910module sync(input clk, input logic d, output logic q); logic n1; always_ff@(posedge clk) begin n1&lt;=d; q&lt;=n1; endendmodule MoreD Latch123456module latch(input logic clk, input logic [3:0] d, output logic [3:0] q); always_latch if (clk) q&lt;=d;endmodule Inverter Using always12345module inv(input logic [3:0] a, output logic [3:0] y); always_comb y=~a;endmodule Full Adder Using always1234567891011module fulladder(input logic a, b, cin, output logic s, cout); logic p, g; always_comb begin p=a^b; g=a&amp;b; s=p^cin; cout=g|(p&amp;cin); endendmodule Seven-Segment Display Decoder12345678910111213141516171819module sevenseg(input logic [3:0] data, output logic [6:0] segments); always_comb case(data) //abc_defg 0: segments = 7'b111_1110; 1: segments = 7'b011_0000; 2: segments = 7'b110_1101; 3: segments = 7'b111_1001; 4: segments = 7'b011_0011; 5: segments = 7'b101_1011; 6: segments = 7'b101_1111; 7: segments = 7'b111_0000; 8: segments = 7'b111_1111; 9: segments = 7'b111_0011; default: segments = 7'b000_0000; endcaseendmodule 3:8 Decoder123456789101112131415module decoder3_8(input logic [2:0] a, output logic [7:0] y); always_comb case(a) 3'b000: y = 8'b00000001; 3'b001: y = 8'b00000010; 3'b010: y = 8'b00000100; 3'b011: y = 8'b00001000; 3'b100: y = 8'b00010000; 3'b101: y = 8'b00100000; 3'b110: y = 8'b01000000; 3'b111: y = 8'b10000000; default: y = 8'bxxxxxxxx; endcaseendmodule Priority Circuit123456789module priorityckt(input logic [3:0] a, output logic [3:0] y); always_comb if(a[3]) y &lt;= 4'b1000; else if (a[2]) y &lt;= 4'b0100; else if (a[1]) y &lt;= 4'b0010; else if (a[0]) y &lt;= 4'b0001; else y &lt;= 4'b0000;endmodule Priority Circuit Using Don’t Cares1234567891011module priority_casez(input logic [3:0] a, output logic [3:0] y); always_comb casez(a) 4'b1???: y &lt;= 4'b1000; 4'b01??: y &lt;= 4'b0100; 4'b001?: y &lt;= 4'b0010; 4'b0001: y &lt;= 4'b0001; default: y &lt;= 4'b0000; endcaseendmodule Finite State MachinesDivide-By-3 Finite State Machines1234567891011121314151617181920module divideby3FSM(input logic clk, input logic reset, output logic y); typedef enum logic [1:0]{S0, S1, S2} statetype; statetype [1:0] state, nextstate; // state register always_ff @(posedge clk, posedge reset) if(reset) state&lt;=S0; else state&lt;=nextstate; //next state logic always_comb case(state) S0: nextstate&lt;=S1; S1: nextstate&lt;=S2; S2: nextstate&lt;=S0; default :nextstate&lt;=S0; endcase //output logic assign y=(state == S0);endmodule Pattern Recognizer Moore FSM123456789101112131415161718192021222324module patternMoore(input logic clk, input logic reset, input logic a, output logic y); typedef enum logic[1:0]{S0,S1,S2} statetype; statetype state, nextstate; //state register always_ff @(posedge clk,posedge reset) if(reset) state &lt;=S0; else state&lt;=nextstate; //next state logic always_comb case(state) S0:if(a) nextstate=S0; else nextstate=S1; S1:if(a) nextstate=S2; else nextstate=S1; S2: if (a) nextstate = S0; else nextstate = S1; default: nextstate = S0; endcase // output logic assign y = (state == S2);endmodule Pattern Recognizer Mealy FSM123456789101112131415161718192021module patternMoore(input logic clk, input logic reset, input logic a, output logic y); typedef enum logic{S0,S1} statetype; statetype state, nextstate; //state register always_ff @(posedge clk,posedge reset) if(reset) state &lt;=S0; else state&lt;=nextstate; //next state logic always_comb case(state) S0: if(a)nextstate=S0; else nextstate=S1; S1: if(a)nextstate=S0; else nextstate=S1; default: nextstate=S0; endcase assign y=(a &amp; state==S1);endmodule Parameterized ModulesParameterized N-Bit 2:1 Multiplexers12345678910111213141516module mux2 #(parameter width=8) (input logic[width-1:0]d0,d1, input logic s, output logic[width-1:0] y); assign y=s?d1:d0;endmodulemodule mux4_12(input logic [11:0] d0,d1,d2,d2, input logic [1:0] s, output logic [11:0] y); logic [11:0] low,hi; mux2 #(12) lowmux(d0,d1,s[0],low); mux2 #(12) himux(d2,d3,s[0],hi); mux2 #(12) outmux(low,hi,s[1],y);endmodule Parameterized N-Input AND Gate1234567891011121314module andN #(parameter width=8) (input logic [width-1:0]a, output logic y); genvar i; logic [width-1:0] x; generate assign x[0]=a[0]; for (i=1;i&lt;width;i=i+1)begin: forloop assign x[i]=a[i]&amp;x[i-1]; end endgenerate assign y=x[width-1];endmodule Testbenches累了，懒得手打了。 3 准则 Use always_ff @(posedge clk) and nonblocking assignments to model synchronous sequential logic. Use continuous assignments to model simple combinational logic. Use always_comb and blocking assignments to model more complicated combinational logic where the always statement is helpful. Do not make assignments to the same signal in more than one always statement or continuous assignment statement. 4 语法查阅运算符优先级表 常数The format for declaring constants is N’Bvalue, where N is the size in bits, B is a letter indicating the base, and value gives the value. An exception is that ‘0 and ‘1 are SystemVerilog idioms for filling a bus with all 0s and all 1s, respectively.","link":"/2022/08/11/Digital-Design-and-Computer-Architecture-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%BD%92%E7%BA%B3/"}],"tags":[{"name":"计算机组成","slug":"计算机组成","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MIPS","slug":"MIPS","link":"/tags/MIPS/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Verilog","slug":"Verilog","link":"/tags/Verilog/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"测试","slug":"测试","link":"/categories/%E6%B5%8B%E8%AF%95/"}]}